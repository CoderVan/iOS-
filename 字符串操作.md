##字符串
####* 字符串比较
```
	比较两个字符串的"内容"是否相同
    BOOL flag = [str1 isEqualToString:str2];
    NSLog(@"flag = %i", flag);
    
    // 下面这个方法, 是比较两个字符串的"地址"是否相同
    flag = (str1 == str2);
    NSLog(@"flag = %i", flag);
    
    // 比较字符串的大小
    [str1 compare:str2]
    * NSOrderedAscending  前面的小于后面的
    * NSOrderedSame,  两个字符串相等
    * NSOrderedDescending  前面的大于后面的

    //忽略大小写进行比较
    [str1 caseInsensitiveCompare:str2]
```
####* 字符串搜索
```
	 // 1.判断是否以什么开头
    // 本质就是从字符串的第一个字符开始匹配, 只要不匹配就返回NO
    if ([str hasPrefix:@"http://"]) {
        NSLog(@"是一个URL");
    }else {
        NSLog(@"不是一个URL");
    }
    
    // 2.判断是否以什么结尾
    // 本质就是从字符串的最后一个字符开始匹配, 只要不匹配就返回NO
    if ([str hasSuffix:@".gif"]) {
        NSLog(@"动态图片");
    }else {
        NSLog(@"不是动态图片");
    }
    
    3.判断字符串中是否包含520it.com
    /*
    NSString *str = @"abcd";
    // 只要str中包含该字符串, 那么就会返回该字符串在str中的起始位置以及该字符串的长度
    // location从0开始 , length从1开始
    // 如果str中没有需要查找的字符串, 那么返回的range的length=0, location = NSNotFound
    NSRange range =  [str rangeOfString:@"lnj"];
    if (range.location == NSNotFound) {
	    if (range.length == 0){
	        NSLog(@"str中没有需要查找的字符串");
	    }else{
	        NSLog(@"str中有需要查找的字符串");
	        NSLog(@"location = %lu, length = %lu", range.location, range.length);
    }
```

####* 字符串截取
```
     // NSRange : 位置/长度
      NSRange range = {6, 3};
      NSRange range;
      range.location = 6;
      range.length = 3;
     // 只要是OC提供的结构体, 一般都可以使用NSMakeXXX来创建
      NSRange range = NSMakeRange(6, 3);  
    // 1.动态获取截取的起始位置
    NSUInteger location = [str rangeOfString:@">"].location + 1;
    // 2.动态获取截取的长度
    // 注意:rangeOfString是从左至右的开始查找, 只要找到就不找了
     NSUInteger length = [str rangeOfString:@"<" options:NSBackwardsSearch].location - location;
    NSUInteger length = [str rangeOfString:@"</"].location - location;
    NSLog(@"location = %lu, length = %lu", location, length);
    NSRange range = NSMakeRange(location, length);
    NSString *newStr = [str substringWithRange:range];
    NSLog(@"str = %@", str);
    NSLog(@"newStr = %@", newStr);
   
    NSString *temp = @"abcdefa";
    NSRange range =[temp rangeOfString:@"a" options:NSBackwardsSearch];
     NSLog(@"%lu", range.location);
    
    // 从什么地方开始截取, 一直截取到最后
    NSString *newStr = [str substringFromIndex:6];
   NSLog(@"newStr = %@", newStr);
    // 从开头开始截取, 一直截取到什么位置
    NSString *newStr = [str substringToIndex:6];
    NSLog(@"newStr = %@", newStr);
     
     <head>小码哥</head> --> 小码哥</head>  --> 小码哥
     <head>小码哥</head> --> <head>小码哥  --> 小码哥
  
    NSLog(@"str = %@", str);
    NSUInteger location = [str rangeOfString:@">"].location + 1;
    NSString *newStr = [str substringFromIndex:location];
    NSLog(@"newStr = %@", newStr);
    
    location = [newStr rangeOfString:@"</"].location;
    // 改变了指针的指向, 并不是修改了原来的字符串
    newStr = [newStr substringToIndex:location];
    NSLog(@"newStr = %@", newStr);

```
####* 字符串替换
```
  // 需求: 将&符号替换为/
    NSString *str = @"http:&&www.520it.com&img&lnj.gif";
    
    // OccurrencesOfString: 要替换谁
    // withString: 用谁替换
    NSString *newStr = [str stringByReplacingOccurrencesOfString:@"&" withString:@"/"];
    NSLog(@"newStr = %@", newStr);
    
    // 1.去除空格  2.将&替换为/
    NSString *str = @"   http:   &&www.   520it.com   &img&lnj.gif   ";
    // 1.去除空格
    NSString *newStr = [str stringByReplacingOccurrencesOfString:@" " withString:@""];
    NSLog(@"newStr = |%@|", newStr);
    NSString *newStr2 = [newStr stringByReplacingOccurrencesOfString:@"&" withString:@"/"];
    NSLog(@"newStr2 = |%@|", newStr2);
    
    // 3.替换首尾
    NSString *str = @"   http:&&www.520it.com&img&lnj.gif   ";
    NSString *str = @"HTTP://www.520it.com/img/LNJ.GIF";
    NSCharacterSet *set = [NSCharacterSet whitespaceCharacterSet];
    NSString *newStr = [str stringByTrimmingCharactersInSet:set];
    NSCharacterSet *set = [NSCharacterSet uppercaseLetterCharacterSet];
    NSString *newStr = [str stringByTrimmingCharactersInSet:set];
    NSLog(@"newStr = |%@|", newStr);
```

####* 字符串与路径
```
 NSString *str = @"User/lnj/Desktop/lnj.txt.jpg";
    // 1.判断是否是绝对路径
    // 其实本质就是判断字符串是否以/开头
    if([str isAbsolutePath])
    {
        NSLog(@"是绝对路径");
    }else{
        NSLog(@"不是绝对路径");
    }
    
    // 2.获取文件路径中的最后一个目录
    // 本质就是获取路径中最后一个/后面的内容
    NSString *newStr = [str lastPathComponent];
    NSLog(@"%@", newStr);
    
    // 3.删除文件路径中的最后一个目录
    // 本质就是删除最后一个/后面的内容, 包括/也会被删除
    NSString *newStr = [str stringByDeletingLastPathComponent];
    NSLog(@"%@", newStr);
    
    // 4.给文件路径添加一个目录
     // 本质就是在字符串的末尾加上一个/ 和指定的内容
     // 注意: 如果路径后面已经有了/, 那么就不会添加了
     //      如果路径后面有多个/, 那么会自动删除多余的/, 只保留一个
     NSString *newStr = [str stringByAppendingPathComponent:@"xmg"];
     NSLog(@"%@", newStr);
    
    // 5.获取路径中文件的扩展名
    // 本质就是从字符串的末尾开始查找., 截取第一个.后面的内容
    NSString *newStr = [str pathExtension];
    NSLog(@"%@", newStr);
    
    // 6.删除路径中文件的扩展名
    // 本质就是从字符串的末尾开始查找.,删除第一个.和.后面的内容
    NSString *newStr = [str stringByDeletingPathExtension];
    NSLog(@"%@", newStr);
    
    // 7.给文件路径添加一个扩展名
    // 本质就是在字符串的末尾加上一个.和指定的内容
    NSString *newStr = [str stringByAppendingPathExtension:@"jpg"];
    NSLog(@"%@", newStr);
```

####* 字符串转换  
```
 	NSString *str = @"abc";
    // 1.将字符串转换为大写
    NSString *newStr = [str uppercaseString];
    
    // 2.将字符串转换为小写
    NSString *newStr2 = [newStr lowercaseString];
    NSLog(@"%@", newStr2);
    
   // htpp://www.520it.com/img/lnj.GIF;
    
    // 3.将字符串的首字符转换为大写
    NSString *newStr = [str capitalizedString];
    NSLog(@"%@", newStr);
    
    // 4.字符串与基本数据类型的转换
    NSString *str1 = @"110";
    NSString *str2 = @"120";
	// str1 + str2; // 错误
    int value1 = [str1 intValue];
    int value2 = [str2 intValue];
    NSLog(@"sum = %i", value1 + value2);
    
    // 注意: 如果不是int,double,float,bool,integer,longlong这些类型就不要乱用
    NSString *str3 = @"abc";
    int value3 = [str3 intValue];
    NSLog(@"value3 = %i", value3);
    
    // 5.C语言字符串和OC字符串之间的转换
    char *cStr = "lnj";
    NSString *str = [NSString stringWithUTF8String:cStr];
    NSLog(@"str = %@", str);
    
    NSString *newStr = @"lmj";
    const char *cStr2 = [newStr UTF8String];
    NSLog(@"cStr2 = %s", cStr2);

```

####* 可变字符串常用方法
```
  NSMutableString *strM = [NSMutableString stringWithFormat:@"www.520it.com.520"];
    
    // 1.在字符串后面添加/image
    [strM appendString:@"/image"];
//    [strM appendFormat:@"/age is %i", 10];
    NSLog(@"strM = %@", strM);
    // 2.删除字符串中的520
    // 技巧: 在开发中, 我们经常利用rangeOfString和deleteCharactersInRange方法配合起来删除指定的字符串
    // 2.1先查找出520在字符串中的位置
    NSRange range = [strM rangeOfString:@"520"];
    // 2.2删除520
    [strM deleteCharactersInRange:range];
    NSLog(@"strM = %@", strM);
    
    // 3.在520前面插入love这个单词
    // insertString : 需要插入的字符串
    // atIndex: 从哪里开始插入
    NSRange range = [strM rangeOfString:@"520"];
    [strM insertString:@"love" atIndex:range.location];
    NSLog(@"strM = %@", strM);
    
    // 4.要求将字符串中的520替换为530
    // 注意: 如果是调用NSString的字符串替换方法, 不会修改原有字符串, 而是生成一个新的字符串
    NSString *newStr =[strM stringByReplacingOccurrencesOfString:@"520" withString:@"530"];
    
    // 注意: 一般情况下OC方法要求传入一个参数如果没有*, 大部分都是枚举
    //      一般情况下如果不想使用枚举的值, 可以传入0, 代表按照系统默认的方式处理
    // OccurrencesOfString: 需要替换的字符串
    // withString: 用什么替换
    // options: 替换时的搜索方式
    // range: 搜索的范围
    // 返回值: 代表替换了多少个字符串
    NSUInteger count = [strM replaceOccurrencesOfString:@"520" withString:@"530" options:0 range:NSMakeRange(0, strM.length)];
    NSLog(@"strM = %@", strM);
    NSLog(@"count = %lu", count);

```

####* 字符串文件读写  
 file: 文件路径  
 encoding: 编码英文 iOS-5988-1 中文 GBK GBK2312 , 一般情况填写UTF-8    
 error: 如果读取错误, 会将错误信息保存到error中 ,如果读取正确, 就没有error = nil
     注意: 以后在OC方法中但凡看到XXXofFile的方法, 传递的一定是全路径(绝对路径)
     
```
	NSString *path = @"/Users/xiaomage/Desktop/课堂共享/day17/note/lnj.txt";  
    NSError *error = nil;
```

####* 从文件中读取字符串

```		
	NSString *str = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:&error];
    if (error == nil) {
        NSLog(@"str = %@", str);
    }else {
        NSLog(@"error = %@", [error localizedDescription]);
    }	
```

####* 将字符串写入到文件中

```
	NSString *str = @"iOS0601基础班";
    // atomically 如果传入YES, 字符串写入文件的过程中如果没有写完, 那么不会生成文件
    //            如果传入NO, 字符串写入文件的过程中如果没有写完, 会生成文件
    NSString *path2 = @"/Users/xiaomage/Desktop/abc.txt";
    BOOL flag = [str writeToFile:path2 atomically:YES encoding:NSUTF8StringEncoding error:nil];
    NSLog(@"flag = %i", flag);
```

####* 文件读取

1.创建URL   
	协议头 + 主机地址 + 文件路径  
	
 ```  
    NSString *path = @"file://192.168.199.199/Users/NJ-Lee/Desktop/lnj.txt";                     
    
   NSString *path = @"http://www.baidu.com";  
 ``` 
注意:如果加载的资源是本机上的资源,那么URL中的主机地址可以省略   
虽然主机地址可以省略,但是需要注意,文件路劲中最前面的/不能省略,文件路径最前面的/代表根路径   

```
    NSString *path = @"file:///Users/NJ-Lee/Desktop/lnj.txt";       
    NSURL *url = [NSURL URLWithString:path];              
    NSString *path = @"file:///Users/NJ-Lee/Desktop/lnj.txt";   
```
  注意:如果是通过NSURL的fileURLWithPath:方法创建URL,那么系统会自动给我们传入的字符串添加协议头(file://),所以字符串中不需要再写file://        
  注意:开发中一 般情况下,如果是访问本机的资源,创建URL的时候,建议使用         fileURLWithPath方法创建      
因为url不支持中文,如果URL中包含中文,那么无法访问;但是如果是通过fileURLWithString方法创建URL,哪怕URL中包含中文也可以进行访问,系统内部会自动对URL中包含的中文进行处理

```
    NSURL *url = [NSURL fileURLWithPath:path];

NSString *path = @"file:///Users/NJ-Lee/Desktop/未命名文件夹/lnj.txt";
	//如果URL中包含中文,又非不通过fileURLWithPath创建,也可以破
 	//如果想破就必须在创建URL之前先对字符串中的中文进行处理,进行百分号编码
	NSLog(@"处理前:%@", path);
	path = [path stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
	NSLog(@"处理后:%@", path);

	NSURL *url = [NSURL URLWithString:path];
	NSLog(@"url = %@", url);
```
```
2.根据URL加载文件中的字符串
NSString *str = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:nil];
NSLog(@"str = %@", str);
```

####* 文件写入
```
NSString *str = @"lnj";
NSString *path = @"file:///Users/NJ-Lee/Desktop/未命名文件夹/abc.txt";
path = [path stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
NSURL *url = [NSURL URLWithString:path];

NSString *path = @"/Users/NJ-Lee/Desktop/未命名文件夹/abc.txt";
NSURL *url = [NSURL fileURLWithPath:path];
[str writeToURL:url atomically:YES encoding:NSUTF8StringEncoding error:nil];

//注意点:如果多次往同一个文件中写入内容,那么后一次的会覆盖前一次的
NSString *str2 = @"xxoo";
[str2 writeToURL:url atomically:YES encoding:NSUTF8StringEncoding error:nil];
```
